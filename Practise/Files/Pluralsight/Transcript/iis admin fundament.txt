Course Overview
Course Overview
Hi everyone, my name is Jeremy Morgan, and welcome to my course, IIS Administration Fundamentals. I've been working with IIS servers for over a decade, managing servers in sizes ranging from small startups, to a Fortune 100 company. IIS Administration is a crucial skill to help you keep your website running well, and delivering awesome functionality. Learning good IIS administration can save you hours of troubleshooting and enable you to unlock awesome features for your website that your visitors will love. In this course we are going to learn some core fundamentals for administering IIS servers. Some of the major topics we will cover include installation and setup, authentication, SSL and TLS, and some administration topics that you need to know. By the end of this course you'll be able to confidently run your own IIS servers, tune their performance, and know what to do when things go wrong. Before beginning this course you should be familiar with general Windows administration, basic web concepts, and PowerShell. I hope you'll join me on this journey to learn IIS administration with the IIS Administration Fundamentals course at Pluralsight. 
Installing IIS 8 in Windows Server 2012
Introduction to Installing IIS 8 in Windows Server 2012
Hi, I'm Jeremy Morgan and I'm a Software DevOps Engineer. I've learned a lot in the trenches managing enterprise IIS servers, and today I'm going to share some of what I've learned with you. In this course we're going to learn IIS Administration Fundamentals. I'm excited to work with you in building a solid understanding of IIS setup and administration. In this module, we're going to start with the basics and compare our options for installing IIS. We'll examine Server Manager, which is a graphical-based installation method, and what we can learn from that. Then we'll take a look at PowerShell as an installation option. Finally, we'll build an installation script in PowerShell that will get us up and running quickly. You'll be able to fully automate your IIS installations. Installing IIS is a critical skill for sysadmins and DevOps professionals, and it's likely something you'll do many times over, so these skills will be crucial to your success. Imagine you're a System Administrator for Acme Widget Corporation. Growth has been through the roof lately and the CIO just informed you that changes need to be made to your existing web infrastructure. The standard hosting account that they've used for years is great, but Acme is starting to outgrow that model, and she would like to take the hosting in-house and provision a server specifically for it. It will be your job to get the website up and operational on your new server. Acme's website is a combination of technologies. It uses HTML, CSS, images, and it's backed by a database. These are the things you need to take into consideration when planning your IIS deployment. Your website won't be hosted the same way that a static website would be. We're going to explore some of the installation options for IIS. While you certainly can just click a few buttons and go, it helps to customize your installation and tailor your installation to your company's needs. As you probably already know, Server Manager is the tool that comes with Microsoft Server 2012 to locate and install packages to your server. It's a graphic interface bundled with Windows Server to simplify setting up your server according to roles, such as web server, Active Directory server, mail server, and many more. Server Manager uses a GUI-based installer which many people prefer. It's laid out very well and it's easy to use. You can see all the modules and options available. You don't have to be an IIS expert to set up a server with this tool. It's very fast and simple to set up for beginners, although many advanced administrators still prefer it. 
Installing IIS with Server Manager
Let's take a look at Server Manager and some of the steps to installing IIS. We will go through adding a web server role and see our options available. In this demo we're going to walk through a very basic IIS install with Server Manager. This is the GUI-based installation option for installing IIS. In Server Manager select All Servers. You may have multiple servers here, if so, select the server that you want to use as an IIS web server. Right-click on that server and select Add Roles and Features. As you can see a wizard comes up explaining what the wizard does and what you should do before you continue. This is a good thing to read over, and then click Next. The Role-based or feature-based installation installs all features on a single server. The Remote Desktop Services installation is for installing a virtual machine-based desktop infrastructure, or a session-based desktop infrastructure. You can distribute logical parts of the Remote Desktop Services role across different servers with this option. Since we're only working with a single server at Acme, let's select Role or feature-based installation, and click Next. Now you can select a server from the server pool. If you're managing multiple servers here, select the server that you intend to be your IIS web server and click Next. Next we have a listing of server roles. This is a list of nearly everything you can do with a Windows server. As you can see, File and Storage Services are already installed. Since we're creating a web server, we want to select the Web Server (IIS) option. Once we do that you can see an option comes up asking if you want to install the management tools. Most of the time you want to select yes here. Click Add Features and then click Next. Now we're getting a little more granular with the install options. This is a list of options for the installation and many of these options are in a tree format. Since we already have the. NET Framework installed, if we want to install ASP. NET 4. 5 we would check this box. For backwards compatibility you also have the. NET 3. 5 features as well. There are many options here for the Web Server Role and I encourage you to explore all of them. Let's go ahead and click Next at this screen. And here's another advisory note, just some things to note about this wizard and how it works. Let's go ahead and click Next at this screen. Now we're down to the real meat of the IIS installation. Here's a listing of the specific IIS options available. Now by default we have some Common HTTP Features checked. If we click Next with the selected options, we'll have a fully functioning web server, although you'll only be able to serve up static pages. In Health and Diagnostics, you have some tools that you may only want to turn on when there's a problem. If you select them now, you'll have them available when that time comes. Under Performance, you have a couple options that you may want to consider. Static Content Compression compresses things like HTML, CSS, JavaScript, and other text files for faster transfer. Dynamic Compression compresses all other dynamic content. This one requires a bit more testing because it uses CPU power to compress it, and it could actually make your site slower. Use with caution. Security, this section is important for securing your web server. You can enable things like Request Filtering that screen incoming requests and apply rules to them, you can have several authentication methods you can enable here, as well as IP and domain restrictions, and URL authorizations to give you great control over you content. Application Development, when you're ready to move beyond a static site, this section will become important. Here's where you can select your. NET extensibility features, enable ASP or ASP. NET, CGI and ISAPI, as well as Server Side Includes and WebSocket Protocol. You won't likely need all these options, but many of them are generally used for compatibility with legacy applications. So do a thorough assessment of your requirements before configuring these options. It's very easy to tack on things that you won't really need. FTP Server, here's an option to install an FTP server or enable extensibility options. And finally we have Management Tools. These are optional and you should only select them if you're sure you're going to need them. For instance, you may prefer to do management remotely or through PowerShell, in which case you may not need a console. This section includes some IIS Management Compatibility, which can be extremely valuable. Select Management Service if you plan on managing this server remotely. Once you click next, you'll be sent to a confirmation screen. This is a good place to review the options you've chosen. You can select to restart the destination server automatically. One neat option here is the ability to export your configuration settings. This concludes our review of installing IIS with Server Manager. We're not actually going to proceed with installing here because we're going to be installing IIS with PowerShell for the Acme website, I just wanted to show the value of Server Manager should you decide to install IIS with it. 
Installing IIS with PowerShell
Now we'll explore another option, installing IIS with PowerShell. You can automate the entire installation process with PowerShell, and we're going to do that for our Acme Widgets web server. Why would you want to use PowerShell? Although it can appear more difficult and cumbersome at first, there can be a few key advantages. It can be a fully automated process that you can even do remotely, it's must less prone to human error. Rather than have a set of instructions with screenshots and lot's of steps, you can have a simple script that can be run to do it all for you. Your PowerShell code can also be stored and versioned like any other type of code, so you can replicate, improve, and troubleshoot your installations. In this demo we'll import the ServerManager module and take a look at some of the ways we can view the features available, and install them to our server. Here we're going to add some Windows features with PowerShell. We're going to be using the PowerShell ISE for this, so in order to load it, right-click on the icon and select Run ISE as Administrator. And now that we've got PowerShell ISE loaded up, let's go ahead and create a new file. To get started we're going to create a temporary folder to use for our installation files. To create a folder, I'm going to type in mkdir, for make directory, C:\temp. And then, we'll type in cd C:\temp. Now when we went through Server Manager the first set of options were core Windows features. Then, we accessed a subset of IIS features. We can actually view all of those available features from PowerShell, and here's how. We will type in Get-WindowsFeature. Now as you can see this is a complete list of features. This is information overload, especially since we're just installing a web server. So to narrow down our selection we can add some parameters to the Get-WindowsFeature command. So we type in Get-WindowsFeature -Name web-*. This will list everything that starts with web-. This will give us a better idea of what modules we may want. Now it may be easier for you to view this in a text editor while selecting your options. Here's how you can accomplish that. Now with the following command we can pipe this in to web. txt. And now, we'll open it up with Notepad. We'll put. \web. txt. This will open it up in your default text editor, and you can select what options you may want, and then copy them into our script. And now, let's start building our installation script for Acme Widgets' new website. The very first thing we'll do is import the ServerManager module. We'll do that by typing in Import-Module ServerManager. And now let's save this file in our temp folder as install. ps1. Now a note here if you've never used PowerShell modules, a module is a set of PowerShell functions grouped together in a unit. A module can contain scripts, assemblies, and other resources. You can reference a module to get a lot of functionality for your scripts, and you can even build your own modules. And now that we have that loaded, we can use the Add-WindowsFeature command. What this does is add in features from the list that we generated earlier. It takes a set of strings separated by commas for each feature that we want. As you can see here we have the Add-WindowsFeature command, and we're putting in a string here like Web-Common-Http, Web-Default-Doc. Everything you add on to the string will all be concatenated and pushed into the Add-WindowsFeature, and all of those features will be installed. Now you can load this all in one line, but it's not very readable. In PowerShell you can put in line breaks that won't affect it with a backtick. This is my preference because it looks much cleaner and it's easier to work with. Next, we want to copy over the files from Acme's website. If you're following along here, you can use any HTML files you want, or just leave the default pages in. Here's how we'll copy Acme's files. Okay now first we have Remove-Item, and as the name implies, the Remove-Item command will remove everything from this default wwwroot folder. Now we put a Recurse parameter so it goes through every directory recursively. With Copy-Item, we want to copy things from the C:\temp\webfiles folder into our wwwroot folder. We'll also do that recursively. Finally, I want to back up this configuration. It may change later, but I'd like to have a snapshot of what it was when we started. To do this, I put in the following line. This creates a backup of our configuration that we can examine later. This copies into your Windows directory under System32\inetsrv\backup. And now that we have our initial script set up, let's go ahead and run it. And it looks like our script has run without any issues. So let's load up the website and see what it looks like. So we'll open up a web browser and type in localhost for the local machine, ta-da, Acme's website is installed and running. We're far from done, but I hope this demo shows how easy it can be to install IIS with PowerShell. 
Installing the .Net Framework with PowerShell
In this demo we will install the. NET Framework with PowerShell. This creates a simple and silent process to make sure the server's up to date with the version of framework that our site requires. Server 2012 comes with. NET 4. 5 as a default, which may work perfectly fine. If we want something newer, however, it will need to be installed. Let's put this in a PowerShell script so we can do this as a step of our deployment process in the future. Now we will navigate to the. NET Framework download page. You want to look for the offline installer for whatever version you want to install. And in our case it's 4. 6. 1. Click on the Download link. Now your security settings will likely prevent you from downloading this file, but we're only going here so that we can copy a link. Look for the link that says If your download does not start after 30 seconds, click here. Right-click on that link, and select Copy shortcut. We'll need this for our script. And now let's open up PowerShell ISE as administrator. Now, create a new PowerShell file and name it. NETinstall. ps1, and let's paste in the URL that we just copied. Let's create a variable called URL, and then we'll assign this URL to that variable. Next, let's create a variable called output, and assign the value C:\temp\dotnet. exe to it. This file does not yet exist, but this will be the location of the. NET Framework installer that we download. Next, we'll use Invoke-WebRequest to download the URL that we copied earlier, and put that into the output variable that we just created. Next, we're going to run the executable that we just downloaded and install the. NET Framework with the parameters passive and norestart. Now as a note, if you're running IIS 7 or 7. 5, you'll want to register our IIS applications with the new version that we just installed. To do that, you'll put in the following line. But since we're running IIS 8 on this machine, we're not going to need it, so we'll go ahead and remove it. And now, our application is ready to install. Let's go ahead and run the script. As you can see here it's downloaded the file into C:\temp\dotnet. exe, and then it has run that file, so now it's extracting files and going through the dotNetInstaller silently. And now, the. NET Framework is installing. And now the install has completed. We've just set up a script to download the newest version of the. NET Framework. Save this script and we can add it into our deployment scripts later if needed. 
Changing the Permissions of the Web Artifacts for the Website
In this demo we're going to build a PowerShell script to change the permissions to all files in a directory. Although this step isn't always necessary, we want to make sure our deployment is dependable and works the same way every time. Let's create a PowerShell script to assign the proper permissions to every file in our web directory. The reason we want to build this script is to ensure that every file in the directory has the proper permissions, especially since we're copying things around a lot. One of the issues with websites is when a file has the wrong permissions, it can be months before anyone tries to access it and you find out it's a problem. Also you may want to run IIS as a different user, in which case you'll need to do this manually, so if that case arises you'll have a script to do it automatically. First, let's create a few variables. We want to put all configurable items at the top of this script for ease of use. The variable named Right contains the permissions you want to assign all the files and folders. You will have all the options that would be available in the GUI. But for our purposes we only need ReadAndExecute. Here are all the possible values that could be available for assigning rights. Principal is who we are going to assign these rights to. In our case it will be the IIS_IUSRS account. Starting directory of course is where we want to start. Next we want to create what's called a foreach loop. This will be familiar to you if you've ever done any kind of scripting or programing before. A foreach loop iterates through items and performs a certain task each time it loops. In our case the Get-ChildItem function starts making a list in our starting directory. Again we're using the recurse flag, so it will go through the entire directory recursively. This will create a listing of files, and I'll show you what that looks like. By typing in Get-ChildItem at the prompt, and specifying the directory with -recurse, we can take a look and see what that file listing is going to look like. As you can see we've got a list of files here, and this is every file in every directory below the c:\inetpub\wwwroot. Foreach will iterate through this list of files and each time it takes a file and places it into that file variable. It will walk its way down the list and execute everything we put in between the two brackets. Now, let's create a new object. This initializes a new instance of the FileSystemAccessRule class. It assigns it a user account, then the type of file system right that we want to assign, and then it specifies to allow it. And it stores all of this in the rule variable. This next line gets the access control list for the file that's inside the loop. Now you'll notice that we're using the file variable, and we're using the FullName property off of that variable in order to get the full path of the file so that we can get the Acl for that. Acl stands for Access Control List. Next, we're going to set the access rule in the Acl to the settings that we specified in the FileSystemAccessRule class. As you can see, we're passing in that rule object to the SetAccessRule method. And then finally, we're going to write the changes to the file. To do that, we're going to call the Set-Acl function, we're going to pass in the full name of the file, and the Acl that we created earlier. Now let's save the script and run it. Since we don't see any errors we can assume the files were changed correctly. We can however go in and verify. As you can see here I have my index. html file open, and under the IIS_IUSRS account we have Read and execute permissions. Now one thing you can do is you can create a line like this. You can create a Write-Output, file, and FullName. Now let's save and run and see what that looks like. As you can see after we run it, it puts a list of files. You may want something like this so that you can verify each file was touched. And that's all there is to it. As I said earlier this is not a required step, but it's good practice, especially when working with large websites. In this module we compared our options for installing IIS. We examined Server Manager as an installation option, as well as PowerShell. We built an initial installation script in PowerShell to install IIS on our web server. Next up we're going to learn about websites and application pools in IIS, and we're going to add more to our Acme Widgets website installation script. 
Creating Websites and Application Pools in IIS
Introduction
In this module we will introduce the concept of websites and application pools in IIS, and how we can use them to make good design decisions when setting up a web server. In this module we're going to examine the concept of websites as they apply to IIS. We will examine different ways to create websites, and decide on an approach for our Acme website. Next we'll examine the concept of application pools and why we need them. Then we'll create a website with some application pools. We'll learn how to modify application pool settings, and then create an implementation for our deployment script for Acme Widgets. Lastly we'll examine virtual directories, their purpose, and how to create them. Now of course you know what a website is, but here we're going to explore what IIS considers a website, and our different options for setting that up. In IIS, a website is a logical container of pages, images, video, and other content that's accessed via a hostname such as Acmewidgetscorp. com or an IP address. It is also a logical container of physical and virtual directories joined by a unique server binding. This binding ties an application, or many applications, to a physical file folder, and when combined, IIS delivers that content to a client. Think of a website as a folder containing everything needed for a website such as Acmewidgetscorp. com. This is a representation of the IIS server hierarchy. The web server may be either a single physical server, or one of many virtual servers. It is considered a single entity in IIS. Within that server we have several websites that can be either individual domains or subdomains. You can have Acmewidgetscorp. com as one website, and Acmetoolsheds. com as another website on the same web server. Alternatively, you can have www. acmewidgetscorp. com as one website, and support. acmewidgetscorp. com on another, yet both on the same web server. The web server is considered a root object. Each website can have one or more applications associated with it. Each of those applications may have one or more virtual directories attached. You can think of this in a tree structure as shown in this diagram. Now there are three ways you can access a website. You can use a fully-qualified domain name such as www. acmewidgetscorp. com, or a hostname that is only available on your local network, such as ACMEWEB. And finally, you can use an IP address to connect with a website. All of these are ways to access a website, and we'll use bindings to make sure that all of these are pointed to the right place. What is a binding? A binding is what associates your method of access to an IIS website. It creates a path between the domain name, hostname, or IP, to the IIS website. And the binding has two attributes, the binding protocol and binding information. The binding protocol determines which protocol the client will use to communicate with the server. For instance, HTTPS. The binding information contains IP, the IP address we want to bind to. If you have multiple network cards and multiple IP addresses, this is very important. Next is port. This is the port we will be using for communication, and you can change this if you'd like. Finally, the host header. This is the domain or server name from the location field of the request header. IP, port name, and host header is the information that's comprised in each binding. 
Demo: Creating a Website in IIS
In this demo we'll create a website for IIS and create a binding for it. We'll look at the different options available for creating websites, and then we'll add this step into our deployment script. Now we're logged on to our server here, and we have files on our default website set up already, but we want to create an additional site because we're going to have several websites on this machine. Let's start by taking a look at what we have. You can look into IIS Manager and visually see the websites that you have set up already, but another way is using PowerShell. Now I have PowerShell ISE open, and what we'll do is type in cd IIS:, and then we'll type in dir. As you can see we have a listing of our AppPools, websites, and SslBindings. This can be another way to view these items. Now let's go in to Sites, and then type in dir there. Here you can see our default site and its binding. This is fine for the default site, but we want to create another website on this domain, so let's create some code in our deployment script to do so. Now this site is going to be called Inside. It's the internal website for Acme Widgets that will be available on inside. acmewidgetscorp. com. Now here are the variables that we'll put at the top of the script. As you can see, we have our physical path where the website will go, its name, and what domain will be pointing to it. I have created a folder at C:\temp\insidewebfiles. In here I've created a generic HTML page that will serve as our internal website page. So if you're following along, just create a basic HTML web page here that will show something different other than our main site. Now let's go in to the Sites directory with our script. And next we're going to create the physical directory that we just specified. We're going to use a cmdlet called Test-Path to make sure that that hasn't already been created. If you look at this loop you can see that we're using Test-Path to see if a website with our name exists. If it does exits it returns true. Now by wrapping this entire function and putting an exclamation in front of it, we're saying if this is not true, do this. The reason I'm doing this is so that we can run this script multiple times, and not try to recreate the site each time. So let's write the code to create the website. Here we will create a new website with the name we specified, in insidename. Then we'll add some bindings. We want this to run as HTTP under port 80, and use the domain name that we specified to load it. And then, we specify the physical path. Now that we've created the site, we'll need to copy the files over for it. But first, let's clear out that folder and make sure there are no old files in it, then we can copy the newer stuff from our temp folder. Now we're going to use Copy-Item to copy our files. Here we are copying every item in the path that we specify, setting the destination, and then using that recurse flag again to copy every file and every directory. Now for good measure, we're going to reset IIS after we create this. And we're going to do that by using invoke-command, with iisreset to be passed. Now, let's run the script. As you can see we have successfully created a new website in IIS, and we have it scripted for repeatability. And now, if we type in dir, we should see that new website. And there it is. We have the new website named inside, it has an ID of 2, it's Started, has a physical path of C:\inetpub\inside, and as you can see we have our bindings set also. In that binding is inside. acmewidgetcorp. com. So let's go ahead and load that up and we'll see if it looks different from our regular Acme website. Okay now we have our main acmewidgetcorp. com website, and let's go ahead and change that to inside. acmewidgetcorp. com. Now as you can see we have our internal website loaded up. And now we have successfully created a new website in IIS. 
What Is an Application Pool?
That application pool is a crucial component of your website and how you use them affects your overall design, so it's important to understand the fundamentals of application pools. An application in IIS is a set of files and folders that deliver content. Every website has a default application, but you can have many more. Each application is assigned a unique application pool. Each application pool spawns a w3wp. exe process in Windows. An application pool is a container for your applications. This helps isolate your applications from other applications on the server. You can have multiple applications within the same application pool, or you can give each application its own pool. There are some careful design considerations to think about when you're setting this up. There are two main reasons to create application pools for each application. Let's say you have several applications in the same pool. This is a simpler design and if you need to change the settings for the pool, you'll only need to do it once and it affects all the applications. Another advantage is caching, which is greatly improved because you build a larger cash of frequently-used code that's shared between all the applications, and that can improve performance. Now this is one possible design for a website. However, if one of your applications crashes, it will take down all the other applications in the pool. Not only is this bad for your website's overall availability, but it makes it harder to narrow down which application actually caused the crash. Also, some applications may have higher loads than others. When you only have one application pool it juggles the load for each application, so depending on your situation, you can have decreased performance when you're sharing an application pool. For this reason, many administrators choose to create an application pool for each application and bind them together. This way if one of the applications fails, it's isolated from the rest. Also, the applications with a higher load will not affect the other applications on the website. This performance advantage can sometimes outweigh the shared caching advantage I mentioned earlier. It's always best to profile your applications and see which configuration fits your situation best. Another advantage of separating your pools is security purposes. You can isolate each application and establish different rules for each, and have different applications run under different users. You can also customize settings for each of those applications as well. Some of the settings you can change in an application pool, recycling settings. This is how often the application pool will be recycled, such as by time intervals, memory, usage, etc. Process security, this is the identity that the w3wp process will run as. Bitness, this setting changes whether the process runs in 64 bit or uses a 32-bit process. This can be very helpful for backwards compatibility. 
Demo: Creating Application Pools
In this demo we'll create an application pool and change some of the settings. We'll create the bindings and take a deeper look at application pools, and then we'll add that to our deployment script. We're going to create some application pools. When we created our website for the internal site, IIS implicitly assigned it to the default application pool, but we are going to create a special application pool just for the internal site. Maybe it's just because I started out with DOS so many moons ago, but I like the simplicity of a prompt. Remember when we used the PowerShell prompt to look at our websites? It turns out we can do the same thing with application pools. We'll type in cd IIS:\AppPools, and then type in dir. And as you can see, we have a list of our application pools here. Now we're back in our deployment script and what we're going to do is we're going to create a new app pool. As we've done before, we want to make sure we create this pool only if it does not exist. We'll do that by using Test-Path again. Next, we'll create the application pool using New-Item. And now, we're going to go into the IIS Manager and take a look at an app pool really quick. And now we're in IIS Manager, so let's go ahead and click on Application Pools, and then we'll right-click on the DefaultAppPool, and select Advanced Settings. These are the settings that are available for our application pool. And as you can see, we have a full list here. Here are the most common settings that I've seen modified,. NET CLR, although there isn't a great reason to run a lower version of. NET, it does happen. Usually I find myself setting this when then DefaultAppPool framework is 2. 0. And in that case I'm just upgrading it to 4. 0. Enable 32-Bit Applications. This is a common one for backwards compatibility. For instance, the last application I worked on that required this used 32-bit DLLs written in C++, and the application would not function without changing this setting. Managed Pipeline Mode, this is another one used for backwards compatibility. You may need Classic Mode for some older ASP applications. Queue Length, this is a throttling setting that can be pretty useful. What we're saying here is that we can have 1000 requests in the queue, and anything above that the visitors will get a 503 error. Limit, limit is another throttling measure that controls the maximum percentage of CPU time you want this application to assume. Limit Actions specifies what to do when that limit is hit. You can either kill the process, throttle it, or do nothing. Limit Interval is for fine tuning your throttling. After the limit that we set above is hit, this setting controls how many minutes we stay in that state until recycling the pool. If it's too long, you may have throttling on long after it's needed. If it's too short, an interval will just keep it throttling. Identity is important because this is the user your application pool is impersonating. Most of the time ApplicationPoolIdentity is the best choice, but there are times when you'll need a specific user to run a process. In that case you can have this app pool run under that user's account, and it is given their permissions. Don't do this unless you absolutely need to. It's something I've seen a lot in the field, especially in high security applications. There are many other settings in your application pool to look at, and I encourage you to fine tune these settings as soon as you've established what your general load patterns are like. Now back at the PowerShell prompt, we can view all of the options by using Get-Item. Now what we did here is we typed in Get-Item, and then IIS:\AppPools\DefaultAppPool, to specify our app pool, and then we piped that in to Select-Object with * for select all. And this will show all the properties that are available for that application pool. Let's get back to creating our application pool for our project. Now for this website we want to make sure our app pool is running the 4. 0 framework, and we need to add in some 32-bit compatibility to it, so we'll use Set-ItemProperty for that. And as you can see, we've set the run time to 4, and enabled 32-bit applications. We've done that by using Set-ItemProperty, with the name of managedRuntimeVersion, and a value of 4. 0. We take that and pipe that output into appPool, which is the variable that we just created with New-Item. Next we use Set-ItemProperty to change the name enable32BitAppOnWin64 to True, and pipe that into our app pool variable. And now, let's go ahead and run this script. And it looks like we've successfully created our app pool. We're not done yet however, because we need to assign our website to this app pool. Since we named our website and the application pool the same thing, we can use the same variable, and this is a short command. We used Set-ItemProperty to change the application pool setting, and set that value to our insidename. And now we'll run it again, and now we can do a quick check. We'll type in dir IIS:\AppPools. Now we can see our inside website uses the inside app pool. We've successfully created an app pool, we've changed some settings, and then assigned it to a website. 
What Is a Virtual Directory?
Now we've talked about websites and the applications within them. And now, we'll explore virtual directories. The last element in our web server node is a virtual directory. A virtual directory is a directory name or path that you map to a physical directory on your local server. The directory name is then included in your URL. A virtual directory is essentially an alias. Let's say we have a URL like this. We could create an actual directory and website root for the admin folder, but we may want it to point to another part of the hard drive, and in that case we would create a virtual directory to point to that new location. There are good reasons we might want to do this. For one, /admin is much shorter that \Custom Applications\acmewidgets\admin. More importantly, you can fine tune your security in different folders, and control what happens inside them. You could create a folder for images that does not allow executables to run, for example. So \images on the website goes to a folder that only allows those images to be served. This reduces the amount of your website that can be exploited. Also, you could specify only a single directory for scripts to be executed, and then lock down the rest of your site. 
Demo: Creating a Virtual Directory
In this demo we'll create a virtual directory for our Acme Widgets site. Creating a virtual directory is a very simple process. So on our Acme site we have an ordering application that's completely separate from the website. However, we want our visitors to be able to go to a \order folder, and order to access it. So let's set that up. Now if you're following along here create a folder in C:inetpub called orderapp, and put an HTML file in there that indicates an order page. You'll notice this is separate from the wwwroot folder that the website is served from. And now we're going to create a script to install this. This is our separate orders application. Now, using Test-Path we're going to check if this virtual directory exists. And now we'll use New-Item to create it. And as you can see we're typing in New-Item, and then IIS:\Sites\Default Web Site\Order, and that specifies where we want it to be located, we specify the physical path which is C:\inetpub\orderapp, and then we specify the type, which is VirtualDirectory. And let's go ahead and run this. And as you can see our virtual directory was created. Let's take a look in IIS Manager and see if we can see that order site. Now we'll open up our Default Web Site, and as you can see we have an Order virtual directory sitting down there at the bottom. So let's load up the web page and see if our virtual folder works. And now we've got the acmewidgetcorp. com website open, and let's do /order. And there's our order page. Now this is outside the website's root, and this could be an actual application that's running that we don't necessarily want to run inside the website root, so the virtual directory has created an alias of /order to go in to that directory on our server. This can be very helpful when running applications, or as I said running secure applications, and it's a very useful tool. 
Summary
In this module we examined the concept of websites as they apply to IIS. We explored different approaches for creating them. We then explored application pools, what they are, and how they're used, and what to consider when creating them. Then we showed how to create them and added that to our final deployment script. We learned how to modify these settings and put the appropriate steps in our deployment script for the Acme Widgets website. Then we examined virtual directories and explained their purpose and showed how to create them. This module will cover some of the essential building blocks of an IIS installation. You will need to know how to configure and install these items when setting up websites on your server. In the next module we'll look at authenticating users for your website, and the different ways we can control access to your digital assets. 
Configuring Authentication
Introduction to Authentication
The title of this module is Configuring Authentication. In this module we're going to examine the concept of authentication in IIS, we're going to review the common types of authentication available, we're going to explore the differences between the options, and then we're going to set up authentication in IIS. No matter how stringent or relaxed your security policies are, you want to be able to control who has access to the assets on your web server. Whether it's a website containing your favorite recipes, or banking information, some basic level of security is required. Out of the box, IIS has many internal features to protect your assets from unauthorized modification. By default, with anonymous authentication it shows assets such as HTML, images, and more to your visitors, without allowing the public to modify them. This is sufficient for a great number of websites out there, but in many cases you'll have files and data that you'll only want some people to see, but not others. And that's when authentication comes in. IIS authentication is designed to make sure we know who a visitor is, and authorization controls what they can access or do. Here's an example of how IIS authentication and authorization work. A visitor makes a request to your server for a file or application, IIS receives the request and checks to see if your IP address and domain are permitted. If you have IIS configured to filter out certain IPs or domains, they'll be denied here. Next is the authentication process. If the domain or IP is permitted, IIS will authenticate the visitor to determine their identity. If you have authentication set up at this point, IIS will ask who this person is, and ask them to verify it. If they cannot prove who they claim to be, they're denied. If they can prove it, they are allowed to continue. If anonymous authentication is enabled, the person is automatically passed through no matter who they are. Next is the authorization process. IIS will verify if this person or identity has permission to access the file or service that they are requesting. If the identity presented is not authorized to access the file or service, they will be denied. If they do have access, the request will be granted and the file or service will be presented to the user. The most common types of authentication used in IIS are as follows. Anonymous, this is the default method of authentication in IIS. The visitor does not supply any credentials, making it effectively anonymous. IIS impersonates a specific user account when processing each request. This is best for public facing websites with assets that are meant to be shared. Basic, this method of authentication asks the visitor to provide a username and password to receive access. The credentials are sent in clear text and the password is stored as a Base64-encoded string on the file system. Accounts are managed by maintaining a text file containing this information, or they are passed through as a regular Windows user account. Digest, this method is similar to basic authentication in that it asks for a username and password, but it is not set in clear text across the network. Accounts are managed on an Active Directory server. Local accounts cannot be used for digest authentication. Integrated Windows authentication, this method is similar to digest authentication, except you can use local accounts as well as Active Directory accounts. It also utilizes the username and password to connect, but those are not sent in clear text. Client certificate, in this method of authentication a client presents a certificate to the server to authenticate. IIS then maps that certificate to a specific user account on the system, allowing the visitor to act as that user on the system, and client certificate requires TLS and SSL to be enabled in IIS. Lastly we have forms-based authentication. This method is different from the others because it relies on an HTML form to manage the authentication. This HTML form is loaded via anonymous authentication and then delivered to the visitor who must complete the requested information. If the user is authenticated they are given a cookie that must be used with each request after that. 
Demo: Setting up Authentication on Our Website
In this demo we're going set up some authentication for our website. We'll go over a couple common options we can use for securing our internal site at Acme Widgets. Earlier we set up an internal site for our employees of Acme Corporation. Let's take a look at some of the ways that we can lock that down. First we're going to try basic auth. As the name implies, basic authentication is pretty basic. It simply accepts a username and password to let you see content. So we'll set that up. Since we may want to add this to our installation scripts, let's go ahead and add this feature with PowerShell. First we're going to do an Import-Module of ServerManager. Then, we're going to do an Add-WindowsFeature and add Web-Basic-Auth. Next we're going to set our basic authentication to be enabled, but first we have to disable anonymous authentication. We do that with Set-WebConfigurationProperty. We put in a filter of /system. webServer/security/authentication/anonymousAuthentication, and the field we're going to change is named enabled, and we're going to change that to a value of false. Our PowerShell path is going to be IIS: and the Location will be inside. Now a note if you're following along is to make sure and change your location. I have mine set to inside because that's the name of the website that we're working on, yours could be different. Next we're going to set our basic authentication to be enabled, and again we're going to use Set-WebConfigurationProperty, and our filter's going to be /system. webServer/security/authentication/windowsAuthentication. We're going to change the enabled field and set that to true. Our PowerShell path is the same and our location is the same. So this is what our whole script will look like right now. Now let's go ahead and run it. And it looks like everything went okay so let's go ahead and try it out. I have an account on this machine named Jeremy and that's what I'm going to use to try to log in. Okay I've got a web browser loaded up here, and I'm going to go to inside. acmewidgetcorp. com. As you can see I have a Windows Security prompt here that's going to ask me for my username and password to get in on this site. Now you'll notice here on the screen it says Warning: Your user name and password will be sent using basic authentication on a connection that isn't secure. Now it's saying that because the username and password are going to be sent over plain text to the server. And now that I've logged in, we can see the Inside ACME Widgets page. Now let's go ahead and set up Windows authentication instead. Back in our PowerShell script we're going to go ahead and delete these two configuration property settings, what we're going to want to do is disable the basic authentication that we were just using. And we'll do that with the Set-WebConfigurationProperty again. We call Set-WebConfigurationProperty, our filter is /system. webServer/security/authentication/basicAuthentication, we're setting the name of enabled to the value of false. And next we're going to enable Windows authentication, and the way we do that is by using the filter /system. webServer/security/authentication/windowsAuthentication, name enabled, set to a value of true. And as you can see that ran correctly, so let's go back to our web page and see what it looks like now. Now I've got a web browser open, and we're going to go to inside. acmewidgetcorp. com again. Now as you can see, we've got the Windows Security prompt again. Now what happens if I type in the wrong name and password here? It'll give us another shot, and after a few tries we get an HTTP error of 401. 1 - Unauthorized. That means we don't have permission to view. But let's go ahead and type in the right password this time. And now I've got my web browser loaded up again, and we're going to go to inside. acmewidgetcorp. com. As you can see, I'm prompted with the Windows Security again, and notice that we don't have the warning this time for basic authentication. That's because our username and password are not going to be supplied with clear text as they were before, now it's going to be an encrypted stream. And now we're in, using Windows authentication. One of the cool things about Windows authentication is it ties in well with ASP. NET apps. You can integrate your roles, usernames and passwords, and other things directly into your web application very nicely. There are many different types of authentication you can set up for your IIS site. From my experience Windows authentication is the most common for internal websites. It's a great way to allow your users access, and you don't have to create or modify new accounts because they're already on the network. Higher security sites often use a certificate or a smart card login. I hope this has shown how simple setting up these types of authentication can be. 
Summary
In this module we examined authentication in IIS. We looked at some of the common types of authentication available, and looked at some of the differences between them. And then, we walked through setting up authentication on our IIS server. In the next module, we'll look at further securing IIS with SSL and TLS. 
Employing SSL and TLS for Our Website
Introduction to SSL and TLS
The title of this module is Employing SSL and TLS for Our Website. In this module we're going to learn what SSL/TLS is. We're going to learn how certificates work in IIS, we're going to examine our installation options, and then we're going to install a self-signed and production certificate in IIS. What is SSL/TLS? Well this can be a bit confusing, but SSL is a cryptographic protocol for providing secure communications over a network. But what was once called SSL is now deprecated and it's succeeded by TLS, or Transport Layer Security. In the industry these are both commonly referred to as SSL, so it can be a bit confusing. At a very high level it's simply a way to encrypt traffic so it isn't easily readable over a network. When using the HTTP protocol, plain text is sent across the network with each request, so someone can maliciously intercept this information. With SSL your information's encrypted, which is especially important if you're exchanging information that you don't want others to see. When a visitor to your website makes a request with SSL, several actions take place. Here's a high level example of the process. The visitor makes a request and a TCP connection is established, and that starts an SSL handshake. The client sends the version of SSL/TLS that it's using, and IIS establishes that connection. Then, IIS requests the ciphers that the client wants to use. Then it establishes which compression methods to use. The server then checks for the highest SSL/TLS version it can use, picks a cipher suite to use, and then selects a compression method. Then the server sends its certificate. Their certificate then has to be trusted by the client, or be issued by a certificate authority that it trusts. This certificate authority cryptographically signs the certificate for this purpose. If the client trusts the certificate, it will send over a public key or a premaster secret, depending on the cypher suite, so that it can compute the encryption needed. The handshake is now complete, and the client and host can share communications securly. Communications between the client and server are now harder to read if someone's able to access that data. Since both the client and server have the key to communicate, they trust each other and send communications freely. To terminate the connection a close notify alert must be issued. If an attacker tries to break this connection, both sides will know that it's not authorized and they will stop communicating. 
Demo: Installing a Self Signed and Public Certificate in IIS
In this demo we will install some certificates to our server for secure communications. First we will install a self-signed certificate. This certificate is used for development purposes only, but it can establish trust for that purpose. Next we'll install a production certificate for acmewidgetcorp. com, so we can allow public access to our server in a secure fashion. We're going to install some certificates on our server. First, let's install a self-signed certificate. This is a certificate created by the host machine that uses the host as its authority. Just by that description you can probably guess that the certificate isn't worth much as a public certificate, these are generally used for development purposes when you need things to be secured with SSL and TLS, but it's just poor development. Here we will load up IIS Manager and click on the server itself, and select Server Certificates. And on the right, we want to click on Create Self-Signed Certificate. In this window you want to put in your domain name. This can be a fully qualified domain name, or a host name. It can even be localhost. For the certificate store select Web Hosting, and click OK. Now, select the website that you want to use, right-click on it, and select Edit Bindings. In this window click Add. You want to select the Type of https, and for the Host name you'll want to put in your domain name again. And for SSL certificate we want to select the one that we just created. And click OK. And now we can load up our page with https. Now I've got a web browser loaded up, and I've got inside. acmewidgetcorp. com, but instead of http, now I've got https. Now you will get an SSL error because the certificate is not from a trusted authority, but you can use this SSL communication for development purposes. Now let's install a trusted SSL certificate for our public facing site. Now we want to go back into the IIS Manager and select Server Certificates again. What I did earlier is I purchased an SSL certificate for this domain. And then, I had to create a certificate request over here on the right-hand side. You fill out your Common name, Organization, Organizational unit, City/locality, State/province, and Country/region. After you've created the certificate request, it will generate a hash that you need to send in to your certificate provider. After I sent in that certificate request they processed it, verified who I was, and then sent me back an answer. This answer's located in a text file that looks like this. It says BEGIN NEW CERTIFICATE REQUEST, has a hash, then END NEW CERTIFICATE REQUEST. At that point we select, over on the right-hand side, Complete Certificate Request. Now here it's going to ask for that file that I just showed you. It says File name containing the certification authority's response. So I'll go ahead and load up my response. And now I've got it pointed to that response file, and I'll put in a Friendly name. This will help me identify it in my list of certificates when I need to select them for my bindings later. And for the certificate store, again we're going to select Web Hosting. And now I have my www. acmewidgetcorp. com certificate installed. And as you can see it's issued by RapidSSL, instead of the host name of the server. Now we'll go ahead and select the default website here, right-click, and select Edit Bindings. And I'll add a new binding here, and select https. For my Host name I'll put in www. acmewigdetcorp. com, and as you can see under SSL certificate, my certificate is available, so I will select that. And then click OK. And now you can see we're getting a warning here. Now the reason we're getting this warning is because we installed an SSL certificate on our internal site on inside, and this is just making sure that we're not creating some kind of conflict. And we're not, so we'll click Yes. And now let's go ahead and bring up the website under https and see what that looks like. And now we've got https://www. acmewidgetcorp. com loaded up with no warnings. And if we click on this it says This connection to the server is encrypted. And that's all you have to do to install SSL certificates on your website. I hope I've shown how easy it is to install SSL certificates to your website. It's good practice to use SSL certificates wherever you can. This protects your customer's data, and your data as well. Also, major search engines are starting to flag sites that have input forms that aren't running SSL. In this module we learned about SSL and TLS and how it applies to IIS. We learned how certificates work in IIS, looked at our installation options, and then installed some SSL certificates for our Acme Widgets website. We installed both a self-signed and production SSL certificate. I hope this has been an informative exercise for setting up SSL on your server. While SSL may have been a nice to have option in the past, it's standard practice now to have SSL on any site that asks for a visitor's information, or any site that contains sensitive information of any kind. Next we're going to look at administering our IIS website, and explore the key skills you'll need to be an effective administrator. 
Administering Our New IIS Website
Introduction to Administering an IIS Website
The title of this module is Administering Our New IIS Website. We're going to take a look at some of the things you'll need to know when running and maintaining our Acme Widgets website. In this module we're going to cover some topics we'll need to know in order to administer the website efficiently. Now that we're getting our server set up, we'll need to configure some items to make sure it's ready to go live. We'll learn about modifying host headers, which is a crucial part of the initial setup, especially if you have multiple domains. Then we'll take a look at MIME types, which are extremely important in setup, and something that can cause you headaches later down the road. We'll talk about some compression options to help speed up your website. I'll cover default documents and some reasons you might want to change these. Finally, we'll examine and configure logging for our website, and look at some of the options available. What are host headers? Host headers allow you to host more than one website domain on the same IP address. When a visitor types www. acmewidgetcorp. com into their browser, that request is sent out to a Domain Name Server, or DNS, that turns the friendly name into an IP address. Then the request is routed to that IP address, which is the address of our IIS server. If an IIS server only hosts a single website, it's a simple process. Any requests that go to that IP address are shown the same web page. IIS listens on that IP address and serves up the default page. If you host more than one more domain on your web server, things become a bit trickier. When the request for each of those websites is sent, the DNS server sends them both to the same IP address. The web server must now decide which website to send acmewidgetcorp. com to, and which website to send csharpworkshop. com to. And it does this with host headers. The browser sends the host header in the request to the server, so IIS will extract that and direct the visitor to the correct website. 
Demo: Looking at Our Host Headers
Let's take a look at our host headers. Now we set up our host headers for acmewidgetcorp. com because we had additional domains on that same server. So let's take a look at our configuration to see how we did that. Now if we take a look at our websites here, let's go into the advanced properties of our default website. Right-click on the website, select Manage Website, and then click on Advanced Settings. Now here if we take a look at our bindings, we can see that we have our http binding for port 80, our https binding for port 443, and then right after that we have a host name of www. acmewidgetcorp. com. This is what IIS will look for in the host name headers, to make sure that requests to this particular domain go to this particular site. Now if we take a look at our inside site we should see a different domain name. And as you can see here in our binding we have inside. acmewidgetcorp. com. This is the host name header that we'll be looking for, so when the browser sends the header with this domain name in it, IIS is going to route it to the inside site instead of the default website. This is a very simple setting, but it can cause huge headaches if it's not set up correctly. Now if we select the inside site, right-click on it and select Edit Bindings, in here we have our bindings for the website. So if we click on it and click Edit, and here's the host name field in case we want to change it. When you're adding new domains to your website, this is the host name that you want to put in for that domain name so that it will be routed to the proper place. This is a very simple setting, but it can cause huge headaches if it's not set up correctly. Now let's take a look at MIME types. 
Introduction to MIME Types
A MIME type is Multipurpose Internet Mail Extension. This is an internet standard for content types delivered by IIS. Each file is assigned a MIME type by its extension, such as. jpg, or. pdf, etc, and the MIME type determines how the file is processed by the web browser. For instance, IIS sends out a file with a. html extension, with a text/html MIME type, and the web browser will handle this file. It will parse this as a text file, and format it appropriately. If it sends out a. jpg file with a MIME type of image/jpg, the browser knows to treat this like an image and display it appropriately. However, if it sends out a. mov file, the browser cannot process this. The MIME type of video/quicktime tells the browser to send this file to a video player to be processed. If IIS sends out a PDF, it will also send out a MIME type to let the browser know to pass it off to a PDF viewer. While these files may be viewable on a browser, giving the impression that the browser itself is processing them, it's actually using a plugin or external program, and MIME types are how we let the browser know how to handle them. 
Demo: Looking at Our MIME Types
In this demo we'll take a look at MIME types and show how to modify or change them on our server. Here's how to examine and change MIME types on your server. Open up IIS Manager, and you can see your MIME types listed by clicking on MIME Types in the features view. IIS configures a ton of MIME types for you. Most of the time you won't even need to look at them. Occasionally however, you'll want to add a MIME type for a file extension that IIS doesn't know. Here's a good example of a time you'll want to add an extension. Font Awesome is an iconic font and CSS toolkit. It does some awesome stuff and you can add some neat pizazz to many of your pages. Newer versions of IIS will have. woff file extensions so that you can use them, but the older ones won't. Also there's a newer font extension called. woff2. It's used commonly and it uses much better compression so the WOFF2 font size can be less than half of that of WOFF files. Now if you use these files on your site, IIS will return a 404, and most browsers will then fall back to the larger. woff1 extension. So you're getting a larger font, and you're getting unnecessary 404s which can clog up your logs. So let's add that MIME type to our server in case we want to use a toolkit with WOFF2 fonts. Now to do this we're going to use add-webconfigurationproperty //staticContent. Our name is going to be collection. The value will be fileExtension=. woff2, the mimeType will be application/font-woff2. So now, let's go ahead and run this. And it's that easy. Now we've added the. woff2 extension, let's go ahead and check and see if it's in our MIME types list. We'll click on our server, and select MIME Types, and as you can see we now have the. woff2 extension installed. This is a relatively small detail in IIS administration, but it can cause you some huge headaches or questions down the road. If you have a custom file type that needs to be processed a certain way by the browser, this is the easiest way to do it. And as I said, IIS puts most of them in there, but every once in a while you'll have something new come out that isn't in there automatically, and this is how you'll add it. You can also add it within the IIS Manager itself. On the right-hand side click on add, and here you have your File name extension, and the MIME type. So that's an easy way to add it with the GUI. I hope this has been a good introduction to MIME types. 
Examining IIS Compression Options
Let's take a look at compression in IIS. IIS compression is useful because it reduces the amount of data that your website transfers, which improves your bandwidth and it can increase the speed of your website. IIS offers two main types of compression. Static compression is used on text-based files such as HTML, CSS, and JavaScript. It also works on documents such as Word documents. Compression takes place every time one of these files changes. There are very few reasons not to enable this as it gives you a nice performance boost with very few downsides. Dynamic compression works on dynamic files such as ASP. NET, classic ASP, and PHP. This type of compression is utilized every time a file is accessed, and this type of compression may use a lot of CPU power, especially under high loads, so it's important to test thoroughly and make sure that it's improving your performance. 
Demo: Setting up Our Default Documents
Let's set up our default documents for our Acme web server. Setting up default documents in IIS is a breeze. Let's create a folder on our site's root called testapp. And now let's load it up in our web browser. Now we can see that it's not shown because we don't allow this folder to be listed. Now inside that folder let's create a file called default. htm. And in that file we'll put in some basic HTML. Here we'll just have an announcement that says This is default. htm. And now we'll refresh the page. As you can see it's shown in your browser. Now let's create one called default. asp. We'll put a little ASP code in here, and what this does is it writes out This is default. asp so we know this is the file being brought up. And go ahead and save it. Now if we bring it up by the exact URL, we can see our ASP page is running correctly. But what happens if we just use the folder in the URL? As you can see we're still showing content from default. htm. That's because default. htm is first in priority. Let's change that. In IIS Manager select your server, then click on the Default Document feature. Now right-click on Default. htm, and select Move Down. And now let's go back to our web browser. Ta-da, we now have the ASP page showing. This list is where IIS goes when you open up a URL that ends with a folder instead of a file name. It goes through this list, starting at the top, and it goes one by one until it finds a file in the folder that matches. So if you have default. asp selected at the top, and you have both default. asp and default. htm in the folder, when you bring up that folder as a URL, default. asp will be shown first, and default. htm will be ignored. Let's create a file called home. htm. And we'll open this up with Notepad, and we're going to put another message in here to tell that This is home. htm, so that we know we're accessing this file. And we'll save it. Now if we refresh our page, we're still getting default. asp, but what we're going to do is we'll create a web. config in that folder, and we'll set the priority to be home. htm over default. asp. Now we'll create a file called web. config, and then we'll put the following in there. Now in our web. config we have a configuration section. Within that section we have system. webServer, and then within there we have defaultDocument enabled= true, and then files add value= home. htm. Now if this works correctly, we should refresh that page and see home. htm instead of default. asp. And there you go, now we're showing home. htm. These are the two ways that you can set your default document in IIS. One advantage of using the web. config to set your default doc is you can set it per folder, which can be very handy. One big reason for changing your default document setup is to make software work. Many types of software use a series of folders with default. asp, or index. php, or something like that in them. If default documents are not configured properly, the software won't work. Another thing to note. Do you notice the order here? This is very important for performance. If your site uses index. html and it's all the way at the bottom, IIS will look for all of these files in the list before showing your index. So it's important to have the right one at the top. Next we're going to take a look at logging in IIS. 
Introduction to Logging in IIS
Let's take a look at logging in IIS. If you've ever spent any time debugging a problem on a server, you know how important logging can be. IIS provides some amazing logging to save you time and energy when diagnosing a problem. There are several modules required for logging in IIS, depending on your needs. The HttpLoggingModule is required as a base for the other loggers. This processes request statuses for http. sys. This will need to be installed for all the other logging modules to work. The FailedRequestsTracingModule is used for logging failed requests. This is usually the first step in the web process, so it's always a good place to start if you're getting an error right up front. The RequestMonitorModule watches executing processes for you. The TracingModule uses event tracing in Windows, and logs the events associated with it. The CustomLoggingModule is exactly what it sounds like. It can be used to generate custom formatted logs. 
Demo: Looking at Our Logging in IIS
Let's take a look at some of our logging options on IIS, and how we can take full advantage of it. Let's look at some of our logging options. The default location for our log files is /inetpub/logs/LogFiles, which I have open here. Logs are collected per site in their own folder with their corresponding ID. As you can see here, we have W3SVC1, and W3SVC2, that corresponds with the IDs of our website 1 and 2. Our default website is ID1, and the inside website is ID2. Now if we open up the folder we can see our logs. Now let's open IIS Manager and take a look at some logging options. Now we'll open up IIS Manager and in the Features window we want to click on Logging. Now the first option here is you have One log file per Server, or per Site. This of course makes it so you can have one log file for the entire server no matter how many sites are on it, or you can do it per site. I generally prefer to do it per site. Next we'll go to Log File and Format. As you can see here we have different types and formats that we can choose from. There are many third-party programs out there for analyzing logs, and this gives you the option of formatting them so they'll work well with these programs. If we click Select Fields, you can choose exactly what fields you want to use. This is extremely important because log files can become very cluttered and it's never fun digging through log files for hours on end looking for something. You can customize the folder that the logs are stored in as well. This can be handy if you expect to have a lot of log files that are very large, you can store them off on another drive. In the next section we choose where to log events. Since logs can take a while to flush to disk, IIS provides an option to use ETW, or Event Tracing for Windows, so that you can view your logs in real time. Here you can choose to log to a file, to ETW, or to both. Log File Rollover is pretty important. You certainly don't want to log everything into a single file. Not only does that make a large, cluttered file to read through, but it can also affect performance. Here you can choose to create a new file Hourly, Daily, Weekly, or Monthly. This is entirely a personal preference. I've worked on some pretty high traffic servers where hourly logs were a must. You can also set the maximum file size so it rolls over if a file gets too big, or you can choose to put it all in one big file. And we have an option here Use local time for file naming and rollover. That's so you can use your local time instead of UTC. Now we're back in the IIS Manager and we'll select on our default website. There may be a time when you run in to an error that's displayed on your page such as a 401, then you go into your logs and find that 401 error was logged, but there's no other information. I ran into this recently when getting a 401, which is permission denied, and I triple checked all the settings I could think of and could not find the problem. That's when a co-worker suggested turning on failed request tracing, and I immediately found the problem. It was due to a certificate revoke list lookup that was failing. It was failing so early that nothing about it was being logged on our log files. This is where failed request tracing comes in very handy. It shows errors in the initial request of the page. To set this up, click on Failed Request Tracing on the right-hand side, and Enable it. And then click OK. Now click on Failed Request Tracing Rules, and here you can set the rules that determine when failed request tracing happens. Right-click in this area and select Add to create a new rule. On the first screen it'll ask you what you want to trace. As you can see you can trace All content, just ASPX pages, classic ASP pages, or something custom. Click Next when you've made your selection. Next you can put in a range of status codes. If you know the code you're expecting, you can make this range very small. I generally put in 400-999, that way I can find the code I'm looking for, like that 401, but I can also catch any other surprise codes that may come up. Here you can select Time taken in case it's a slow page that's causing the errors. Finally, you can select the Event severity if you want to narrow down the type of event you want to capture. And then we click Next from here. Next we have our trace providers. Again, we can look for classic ASP, ASP. NET, ISAPI Extension, or WWW Server. I generally leave all of these selected in case I catch a surprise error from one of them. Now we'll go ahead and select ASP, you can then select Verbosity, which determines how much information is captured and reported. You may only want Critical Errors or just Warnings, or maybe you want everything. This is kind of like a fishing net that you're casting out, the wider the net, the more you'll catch, but you may end up with more than the fish that you want in your net. For simplicity it may be easier to narrow down exactly what you're looking for. After you click finish, your server will start catching all the failed requests. If you're using ASP. NET, there's a special tracing feature that can be pretty handy. You can actually set this up per page. So let's create a file called test. aspx, and we'll add the following to it. Now that we have test. aspx open, let's go ahead and create this tag that says Page Trace = True. Now we'll load this up in our web browser. As you can see we get some extremely detailed information about the page. Now our test. aspx doesn't actually have anything in it, but if it were an actual. aspx file, you would be able to load it and it would tell you all this information. For example, we have our Trace Information that shows from the Begin PreInit, down to the end of the render of the page, and how long it took. Another important one is Request Cookies Collection. And we have our Headers Collection here, as well as the Response Headers Collection that's returned. And here's our list of Server Variables. This is a good thing to look at because it's going to show the state of all those variable when you loaded up that page. You can also add this at the server level. And let's look at how to do that. We have our web. config open here, and in system. web I've created a tag named trace. We've set enabled to true, and pageOutput to true, which means it's going to output it to a page like we saw before. The request limit is set to 40, that means it's going to be for 40 requests only. And we have localOnly set to false, which means we can view this outside the server. If we set local only to true, that means we'll only be able to view this information if we're on a web browser on the local computer. I can't tell you how many times this has come in handy when doing ASP. NET development. It can really narrow down your problem and save you a bunch of time in debugging. And that concludes our demo for logging on IIS. 
Course Summary
In this module we learned about modifying our host headers. We took a look at MIME types, compression options, and set our default documents. We then took a look at logging and some of the options available there. I hope this has given you some good information about administering IIS servers, and exposed you to some features and techniques that can be quite useful. In this course we covered many fundamentals of administering IIS by building the website for Acme Widgets. We covered the installation of IIS, we looked at some of the options for installing it, and how to get started. Then we looked at creating websites and application pools, the building blocks of the Acme site. We then explored authentication, and some of the options there, to make sure the right people access the content they're supposed to. Then we covered SSL and TLS, and how we can secure communications on our website. Lastly we covered administering IIS and some of the things you'll need to know for setup and day-to-day operations. What's next? Go out there and set up your IIS server. If this is something you chose to learn to help you with your current position, start digging in and examing ways you can help effectively administer your website for your organization. If this is not a part of your day-to-day job, go out and obtain a virtual server and put a website on it. Those just for fun type projects can be an excellent teacher and you have some freedom to play around and experiment. There are some great courses here on Pluralsight for furthering your knowledge in this area, including setting up virtual networks on Azure, and extending IIS by building custom modules and handlers. The possibilities here are endless. I hope you've enjoyed this course. Feel free to join the Discussion area of this course if you have any questions or comments regarding IIS Administration Fundamentals. 